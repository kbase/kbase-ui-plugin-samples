import {
    FieldNumberValue,
    FieldStringValue,
    FieldValue,
    Format,
    SchemaField,
    UserFieldValue,
} from "lib/client/samples/Samples";
import { MetadataValue, SampleId, SampleNodeType, SampleVersion, Sample as RawSample, } from "lib/client/Sample";
import { EpochTimeMS, SimpleMap, SimpleMapping, Username } from "../types";
import SampleServiceClient, {
    DataLink, GetFormatParams, GetFormatResult, GetSampleACLsParams, GetSampleACLsResult, GetSampleParams
} from "../client/SampleServiceClient";

// Constants

import { UPSTREAM_TIMEOUT } from "../../appConstants";
import { Workspace } from "@kbase/ui-lib";
import { ObjectInfo } from "@kbase/ui-lib/lib/lib/comm/coreServices/Workspace";
import { LinkedData } from "redux/store/linkedData";
import UserProfileClient, { UserProfile } from "@kbase/ui-lib/lib/lib/comm/coreServices/UserProfile";

import sesarTemplateData from "./data/templates/sesar/sesar1.json";
import enigmaTemplateData from "./data/templates/enigma/enigma1.json";
import { grokFormat } from "./patch/utils";

// Types

export type FieldDefinitionsMap = { [key: string]: SchemaField; };

export interface Sample {
    // id generated by sample service
    id: SampleId;

    // supplied in the sample as the ____
    name: string;

    // supplied in the sample as some field mapped to the sample id; must be
    // unique
    sampleId: string;

    // Supplied in the sample as some field mapped to another sample
    parentSampleId: string | null;

    // Chosen in the sample importer; is it used for anything?
    type: string;

    created: {
        at: EpochTimeMS;
        by: User;
    };

    currentVersion: {
        at: EpochTimeMS;
        by: User;
        version: number;
    };
    latestVersion: {
        at: EpochTimeMS;
        by: User;
        version: number;
    };

    metadata: Array<MetadataField>;
    controlled: SimpleMap<MetadataControlledField>;
    formatId: string;
    // template: Template;
    format: Format;
}

export interface User {
    username: Username;
    realname: string;
    gravatarHash: string;
    avatarOption?: string;
    gravatarDefault?: string;
}

// Template

export interface TemplateFieldBase {
    type: string;
}

export interface TemplateFormatField extends TemplateFieldBase {
    type: "metadata";
    key: string;
}

export interface TemplateUserField extends TemplateFieldBase {
    type: "user";
    key: string; // really isn't a key for a user field, but that is all that the
    // sample service gives us for them, so we have to keep it in our
    // fake, and maybe eventually in the real template, so we can use
    // it to pluck the user metadata field out of the samples' meta_user
    label: string;
}

export type TemplateField = TemplateFormatField | TemplateUserField;

// For now, a template is simply an ordered set of sample field keys.
// export type Template = {
//     header?: Array<string>;
//     fields: Array<TemplateField>;
// };

// Metadata

export interface UserMetadata {
    [label: string]: string;
}

export interface MetadataFieldBase {
    type: string;
    key: string;
    label: string;
    isEmpty: boolean;
}

export interface MetadataControlledField extends MetadataFieldBase {
    type: "controlled";
    field: FieldValue;
}

export interface MetadataUserField extends MetadataFieldBase {
    type: "user";
    field: UserFieldValue;
}

export type MetadataField =
    | MetadataControlledField
    | MetadataUserField;

export interface MetadataSource {
    [key: string]: MetadataSourceField;
}

export interface MetadataSourceField {
    key: string;
    label: string;
    value: string;
}

export type FormatName = string;

export interface FetchSampleProps {
    serviceWizardURL: string;
    userProfileURL: string;
    token: string;
    sampleId: SampleId;
    sampleVersion?: SampleVersion;
    setTitle: (title: string) => void;
}

export interface UserProfileMap {
    [username: string]: UserProfile;
}

export interface ACL {
    admin: Array<User>;
    write: Array<User>;
    read: Array<User>;
}

export interface DataLink2 extends DataLink {
    key: string;
    objectType: string;
    objectName: string;
}

export interface GetSampleResult {
    id: SampleId;
    name: string;
    savedAt: EpochTimeMS;
    savedBy: Username;
    version: SampleVersion;
    sample: {
        id: string;
        parentId: string | null;
        type: SampleNodeType;
        metadata: Array<MetadataField>;
        controlled: SimpleMap<MetadataControlledField>;
    };
    formatId: string;
}

export default class ViewModel {
    userProfileURL: string;
    sampleServiceURL: string;
    workspaceURL: string;
    token: string;
    timeout: number;
    sampleService: SampleServiceClient;

    constructor(
        {
            userProfileURL,
            sampleServiceURL,
            workspaceURL,
            serviceWizardURL,
            token,
            timeout,
        }: {
            userProfileURL: string;
            sampleServiceURL: string;
            workspaceURL: string;
            serviceWizardURL: string;
            token: string;
            timeout: number;
        },
    ) {
        this.userProfileURL = userProfileURL;
        this.sampleServiceURL = sampleServiceURL;
        this.workspaceURL = workspaceURL;
        this.token = token;
        this.timeout = timeout;
        this.sampleService = new SampleServiceClient({
            url: this.sampleServiceURL,
            serviceWizardURL,
            token,
            timeout
        });
    }

    async fetchUsers(
        { usernames }: { usernames: Array<Username>; },
    ): Promise<Array<User>> {
        const userProfileClient = new UserProfileClient({
            token: this.token,
            url: this.userProfileURL,
            timeout: UPSTREAM_TIMEOUT,
        });

        const profiles = await userProfileClient.get_user_profile(usernames);

        if (profiles.length !== usernames.length) {
            const profileUsernames = profiles.map(({ user: { username } }) => {
                return username;
            });
            const missing = usernames.filter((username) => {
                return !profileUsernames.includes(username);
            });
            throw new Error(`Users could not be found: ${missing.join(', ')}`);
        }

        return profiles.map((profile) => {
            const {
                user: {
                    username,
                    realname,
                },
                profile: {
                    synced: {
                        gravatarHash,
                    },
                    userdata: {
                        gravatarDefault,
                        avatarOption,
                    },
                },
            } = profile;
            return {
                username,
                realname,
                gravatarHash,
                gravatarDefault,
                avatarOption,
            };
        });
    }

    async fetchSample(
        { id: sampleId, version: sampleVersion }: { id: string; version?: number; },
    ): Promise<Sample> {
        const sampleResult = await this.getSample({
            id: sampleId,
            version: sampleVersion,
        });

        const latestSample = await this.getSample({
            id: sampleId,
        });

        const firstSample = await (async () => {
            if (sampleResult.version === 1) {
                return sampleResult;
            }
            return await this.getSample({
                id: sampleId,
                version: 1,
            });
        })();

        const users = await this.fetchUsers({
            usernames: Array.from(new Set([
                firstSample.savedBy,
                sampleResult.savedBy,
                latestSample.savedBy,
            ]).values()),
        });

        const usersMap = users.reduce((usersMap, user) => {
            usersMap.set(user.username, user);
            return usersMap;
        }, new Map<Username, User>());

        // const fieldKeys: Array<string> = Object.keys(sampleResult.sample.controlled);
        const { format } = await this.getFormat({ id: sampleResult.formatId });
        // const {fields} = await client.getFieldDefinitions({keys: fieldKeys});

        const sample: Sample = {
            id: sampleResult.id,
            sampleId: sampleResult.sample.id,
            parentSampleId: sampleResult.sample.parentId,
            type: sampleResult.sample.type,
            name: sampleResult.name,
            created: {
                at: firstSample.savedAt,
                by: usersMap.get(firstSample.savedBy)!,
            },
            currentVersion: {
                at: sampleResult.savedAt,
                by: usersMap.get(sampleResult.savedBy)!,
                version: sampleResult.version,
            },
            latestVersion: {
                at: latestSample.savedAt,
                by: usersMap.get(latestSample.savedBy)!,
                version: latestSample.version,
            },
            metadata: sampleResult.sample.metadata,
            controlled: sampleResult.sample.controlled,
            formatId: sampleResult.formatId,
            format
            //template: sampleResult.template,
        };
        return sample;
    }

    async fetchACL({ id }: { id: string; }): Promise<ACL> {
        const aclResult = await this.sampleService.get_sample_acls({
            id,
            as_admin: 0,
        });

        const usersToFetch: Array<Username> = aclResult.admin.concat(
            aclResult.read,
        ).concat(aclResult.write);

        const userProfileClient = new UserProfileClient({
            token: this.token,
            url: this.userProfileURL,
            timeout: UPSTREAM_TIMEOUT,
        });

        const profiles = await userProfileClient.get_user_profile(usersToFetch);
        const profileMap: UserProfileMap = profiles.reduce<UserProfileMap>(
            (profileMap, profile) => {
                profileMap[profile.user.username] = profile;
                return profileMap;
            },
            {},
        );

        const acl: ACL = {
            admin: aclResult.admin.map((username) => {
                const profile = profileMap[username];
                return {
                    username,
                    realname: profile.user.realname,
                    gravatarHash: profile.profile.synced.gravatarHash,
                    gravatarDefault: profile.profile.userdata.gravatarDefault,
                    avatarOption: profile.profile.userdata.avatarOption,
                };
            }),
            write: aclResult.write.map((username) => {
                const profile = profileMap[username];
                return {
                    username,
                    realname: profile.user.realname,
                    gravatarHash: profile.profile.synced.gravatarHash,
                    gravatarDefault: profile.profile.userdata.gravatarDefault,
                    avatarOption: profile.profile.userdata.avatarOption,
                };
            }),
            read: aclResult.read.map((username) => {
                const profile = profileMap[username];
                return {
                    username,
                    realname: profile.user.realname,
                    gravatarHash: profile.profile.synced.gravatarHash,
                    gravatarDefault: profile.profile.userdata.gravatarDefault,
                    avatarOption: profile.profile.userdata.avatarOption,
                };
            }),
        };

        return acl;
    }

    async fetchLinkedData({ id, version }: {
        id: string;
        version: number;
    }): Promise<LinkedData> {
        const dataLinks = await this.sampleService.get_data_links_from_sample({
            id: id,
            version: version,
        });

        const objectRefs = dataLinks.links.map((dataLink) => {
            return dataLink.upa;
        });

        if (objectRefs.length === 0) {
            return [];
        }

        const workspaceClient = new Workspace({
            token: this.token,
            url: this.workspaceURL,
            timeout: UPSTREAM_TIMEOUT,
        });

        const objectInfos = await workspaceClient.get_object_info3({
            includeMetadata: 1,
            objects: objectRefs.map((ref) => {
                return { ref };
            }),
        });

        const objectMap = objectInfos.infos.reduce((objectMap, info) => {
            const [objectId, , , , version, , workspaceId] = info;
            const ref = [workspaceId, objectId, version].join("/");
            objectMap.set(ref, info);
            return objectMap;
        }, new Map<string, ObjectInfo>());

        const dataLinksWithKey: Array<DataLink2> = dataLinks.links.map(
            (dataLink) => {
                const objectInfo = objectMap.get(dataLink.upa);
                if (!objectInfo) {
                    throw new Error("Object not found: " + dataLink.upa);
                }
                return {
                    ...dataLink,
                    key: dataLink.upa,
                    objectName: objectInfo[1],
                    objectType: objectInfo[2],
                };
            },
        );

        return dataLinksWithKey;
    }

    async getFormat(params: GetFormatParams): Promise<GetFormatResult> {
        const { format } = await this.sampleService.get_format({ id: params.id });
        return { format };
    }


    getACL(params: GetSampleACLsParams): Promise<GetSampleACLsResult> {
        return this.sampleService.get_sample_acls(params);
    }

    async getSample(params: GetSampleParams): Promise<GetSampleResult> {
        // 1. Get the sample.
        const rawSample = await this.sampleService.get_sample(params);
        const rawRealSample = rawSample.node_tree[0];

        // 1.5: get additional sample properties
        const format_id = grokFormat(rawSample);

        // 2. Get the format
        const { format } = await this.sampleService.get_format({ id: format_id });
        const sampleMapping = format.mappings.sample;
        const reverseSampleMapping: SimpleMapping = Object.entries(sampleMapping)
            .reduce<SimpleMapping>((mapping, [key, value]) => {
                mapping[value] = key;
                return mapping;
            }, {});

        const recordMapping = format.mappings.record;
        const reverseRecordMapping: SimpleMapping = Object.entries(recordMapping)
            .reduce<SimpleMapping>((mapping, [key, value]) => {
                mapping[value] = key;
                return mapping;
            }, {});

        // const correctionMapping = format.mappings.corrections || {};
        // const reverseCorrectionMapping: SimpleMapping = Object.entries(correctionMapping).reduce<SimpleMapping>((mapping, [key, value]) => {
        //     mapping[value] = key;
        //     return mapping;
        // }, {});
        // const formatVersion = 1;

        // 3. Get the template.
        // FAKE: now pretend we are fetching the sample set associated with this sample,
        // which will include the template used to upload.
        // const template: Template = this.getTemplate(rawSample, format);

        // 2. Get the field definitions for this sample.
        // const keys = template.fields
        //     .filter((field) => {
        //         return field.type === "metadata";
        //     })
        //     .map((field) => {
        //         if (field.type === "metadata") {
        //             return field.key;
        //         } else {
        //             throw new Error("Impossible!");
        //         }
        //     });

        const controlledKeys = Object.keys(rawSample.node_tree[0].meta_controlled);

        const { fields } = await this.sampleService.get_field_definitions({ keys: controlledKeys });

        // Make a map for quick lookup.
        const fieldDefinitions: Map<string, SchemaField> = fields.reduce(
            (defMap, fieldDef) => {
                defMap.set(fieldDef.kbase.sample.key, fieldDef);
                return defMap;
            },
            new Map(),
        );

        // We expand the metadata into the full template.
        // const sampleMappings = format.mappings.sample as { [key: string]: string };
        // const correctionMappings = format.mappings.corrections || {};
        // const recordMappings = format.mappings.record || {};

        // We reconstruct the full metadata here, using the definition of the metadata for this format.
        // A few gotchas here.
        // Currently the sample importer will transform some sample fields into canonical non-metadata fields:
        // id - the user supplied id (e.g. sample_id for enigma, igsn for sesar)
        // parent_id - the user supplied parent id (e.g. well_name for enigma, parent_igsn for sesar)
        // name -- ???
        // we reverse those back to their original sample field names for metadata. They are of retained in the
        // sample outside of the metadata.
        // This is done using the mappings part of the sample format definition.
        // Specifically mappings.sample provides a mapping from the sample fields (id, parent_id) to the
        // format-specific names for those fields.
        //
        // Another gotcha is that some fields end up weird after the sample import transformation.
        // See, the sample importer will construct keys schema of column names using certain rules, e.g. space to underscore.
        // This results in some strange keys.
        // I refuse to replicate that in the format spec, but accommodate that (for now ONLY) using a "corrections" mapping.
        // This mapping, mappings.corrections, maps from the incorrect to the correct field.
        // e.g. redox_potential_?: redox_potential

        // Simulate template fields.
        const controlledFields: Array<MetadataControlledField> = Object.entries(rawRealSample.meta_controlled).map(([key, { value, units }]): MetadataControlledField => {
            const def = fieldDefinitions.get(key);
            if (!def) {
                throw new Error(`Undefined  field "${key}"`);
            }
            const field = ((): FieldValue => {
                switch (def?.type) {
                    case "number":
                        if (typeof value !== 'number') {
                            throw new Error('Field should be number but is not');
                        }
                        const n: FieldNumberValue = {
                            type: 'number',
                            isEmpty: false,
                            schema: def,
                            numberValue: value,
                            unit: units
                        };
                        return n;
                    case "string":
                        if (typeof value !== 'string') {
                            throw new Error('Field should be string but is not');
                        }
                        const s: FieldStringValue = {
                            type: 'string',
                            isEmpty: false,
                            schema: def,
                            stringValue: value,
                            unit: units
                        };
                        return s;
                }
            })();
            if (def) {
                return {
                    type: 'controlled',
                    key,
                    label: def.kbase.display.label,
                    isEmpty: false,
                    field
                };
            } else {
                return {
                    type: 'controlled',
                    key,
                    label: key,
                    isEmpty: false,
                    field
                };
            }
        });
        const userFields: Array<MetadataUserField> = Object.entries(rawSample.node_tree[0].meta_user).map(([key, value]) => {

            return {
                key,
                type: 'user',
                isEmpty: false,
                label: key,
                field: value.value
            };
        });
        const allFields = [...controlledFields, ...userFields];

        const controlled: SimpleMap<MetadataControlledField> = {};
        const metadata = allFields.map<MetadataField>((templateField) => {
            // Skip user fields in the template.
            if (templateField.type === "user") {
                const userFieldValue = rawRealSample.meta_user[templateField.key].value;
                const [key, label] = (() => {
                    if (templateField.key in rawRealSample.meta_controlled) {
                        return [`user:${templateField.key}`, `user:${templateField.key}`];
                    } else {
                        return [templateField.key, templateField.key];
                    }
                })();
                const a: MetadataUserField = {
                    type: "user",
                    key,
                    label,
                    isEmpty: userFieldValue ? true : false,
                    field: userFieldValue
                };
                return a;
            }

            const fieldDefinition = fieldDefinitions.get(templateField.key);

            if (!fieldDefinition) {
                console.error("undefined field", fieldDefinitions, templateField.key);
                throw new Error(
                    `Sorry, field "${templateField.key}" is not defined`,
                );
            }

            // map the template key back to the mapped key.
            const reverseMappedKey = ((key) => {
                // sample mapping is first, because the record mapping (name)
                // may be the same as the sample mapping (id)
                if (key in reverseSampleMapping) {
                    return reverseSampleMapping[key];
                }
                if (key in reverseRecordMapping) {
                    return reverseRecordMapping[key];
                }

                return key;
            })(templateField.key);

            const mappedKey = templateField.key;

            const fieldValue: MetadataValue | null = (() => {
                const value = rawRealSample.meta_controlled[reverseMappedKey];
                if (typeof value === "undefined") {
                    return null;
                }
                return value;
            })();

            const unit = (() => {
                if (fieldValue && fieldValue.units) {
                    return fieldValue.units;
                }
                if (!fieldDefinition.kbase.units) {
                    return "unit";
                }
                if (!fieldDefinition.kbase.units.canonical) {
                    return "unit";
                }
                return fieldDefinition.kbase.units.canonical;
            })();

            const field: FieldValue = (() => {
                switch (fieldDefinition.type) {
                    case "string":
                        const y: FieldStringValue = {
                            type: "string",
                            format: fieldDefinition.format,
                            schema: fieldDefinition,
                            isEmpty: fieldValue === null,
                            unit: fieldValue !== null ? fieldValue.units : undefined,
                            stringValue: fieldValue === null
                                ? fieldValue
                                : fieldValue.value as string,
                        };
                        return y;
                    // case "text":
                    //     return {
                    //         schema: fieldDefinition,
                    //         value: fieldValue === null
                    //             ? fieldValue
                    //             : fieldValue.value as string | null,
                    //     };
                    case "number":
                        const x: FieldNumberValue = {
                            type: "number",
                            schema: fieldDefinition,
                            isEmpty: fieldValue === null,
                            unit: fieldValue !== null ? fieldValue.units : undefined,
                            numberValue: fieldValue === null
                                ? fieldValue
                                : fieldValue.value as number,
                        };
                        return x;
                    // case "boolean":
                    //     return {
                    //         schema: fieldDefinition,
                    //         value: fieldValue === null
                    //             ? fieldValue
                    //             : fieldValue.value as boolean | null,
                    //     };
                    // case "Enum<string>":
                    //     return {
                    //         ...fieldDefinition.type,
                    //         value: fieldValue === null
                    //             ? fieldValue
                    //             : fieldValue.value as string | null,
                    //     };
                    // case "OntologyTerm":
                    //     return {
                    //         ...fieldDefinition.type,
                    //         value: fieldValue === null
                    //             ? fieldValue
                    //             : fieldValue.value as string | null,
                    //     };
                    // default:
                    //     throw new Error(
                    //         `Unsupported field type ${fieldDefinition.type}`,
                    //     );
                }
            })();

            const controlledField: MetadataControlledField = {
                type: "controlled",
                key: mappedKey,
                label: fieldDefinition.kbase.display.label,
                isEmpty: field.isEmpty,
                field,
            };
            controlled[mappedKey] = controlledField;
            return controlledField;
        });

        return {
            id: rawSample.id,
            name: rawSample.name,
            savedAt: rawSample.save_date,
            savedBy: rawSample.user,
            version: rawSample.version,
            sample: {
                id: rawRealSample.id,
                type: rawRealSample.type,
                parentId: rawRealSample.parent,
                metadata,
                controlled,
            },
            formatId: format_id
        };
    }

    // HACK ALERT: this is not how a template will live in real life
    // TODO: replace when/if templates are supported.
    // getTemplate(
    //     rawSample: RawSample,
    //     format: Format,
    //     // fieldDefinitions: FieldDefinitions,
    // ): Template {
    //     // This is the hardcoded "template"
    //     const format_id = grokFormat(rawSample);
    //     const templateData: { fields: Array<string>; } = (() => {
    //         switch (format_id) {
    //             case "sesar":
    //                 return sesarTemplateData;
    //             case "enigma":
    //                 return enigmaTemplateData;
    //             case "kbase":
    //                 return {
    //                     fields: [],
    //                 };
    //             default:
    //                 throw new Error(
    //                     `Sorry, no template for format ${format_id}`,
    //                 );
    //         }
    //     })();

    //     const sampleMapping = format.mappings.sample as SimpleMapping;
    //     const recordMapping = format.mappings.record as SimpleMapping;

    //     const getMappedKey = (key: string) => {
    //         if (key in recordMapping) {
    //             return recordMapping[key];
    //         }
    //         if (key in sampleMapping) {
    //             return sampleMapping[key];
    //         }
    //     };

    //     const templateFieldKeys = templateData.fields;

    //     const metadataFields: Array<TemplateField> = templateFieldKeys.map(
    //         (key) => {
    //             return {
    //                 type: "metadata",
    //                 key,
    //             };
    //         },
    //     );

    //     // now we fetch the user fields from the sample
    //     const userFields: Array<TemplateField> = Object.keys(
    //         rawSample.node_tree[0].meta_user,
    //     )
    //         .filter((key) => {
    //             // Here we filter out user keys which are (in error)
    //             // included in the controlled metadata. This is due
    //             // to a bug in the importer, and this code should
    //             // eventually be removed.
    //             return !(key in rawSample.node_tree[0].meta_controlled);
    //         })
    //         .map((key) => {
    //             // user fields are not in source_meta.
    //             // but since there have been import bugs regarding
    //             // incorrect user metadata, we have to detect if they
    //             // are actually controlled fields.
    //             const label = (() => {
    //                 if (templateFieldKeys.includes(key)) {
    //                     return `USER ${key}`;
    //                 }
    //                 return key;
    //             })();

    //             return {
    //                 type: "user",
    //                 key,
    //                 label,
    //             };
    //         });

    //     // const userFields: Array<TemplateField> = userFieldLabels.map((label) => {
    //     //   return {
    //     //     type: "user",
    //     //     label,
    //     //   };
    //     // });

    //     const templateFields = templateFieldKeys.reduce<Set<string>>(
    //         (fields, field) => {
    //             fields.add(field);
    //             return fields;
    //         },
    //         new Set(),
    //     );

    //     // Here we handle controlled fields which we know are absent because they
    //     // are in the template, but not in the sample itself.
    //     const missingMetadataFields: Array<TemplateField> = Object.entries(
    //         rawSample.node_tree[0].meta_controlled,
    //     ).reduce<Array<TemplateField>>((fields, [key, value]) => {
    //         // In our model, we map the special keys name, id, parent_id back to their
    //         // original fields. The original field names may be in the canned template above.
    //         const mappedKey = getMappedKey(key) || key;
    //         if (mappedKey && templateFields.has(mappedKey)) {
    //             return fields;
    //         }
    //         fields.push({
    //             type: "metadata",
    //             key: mappedKey,
    //         });
    //         return fields;
    //     }, []);

    //     const fields = metadataFields.concat(missingMetadataFields).concat(
    //         userFields,
    //     );

    //     // now we merge them together into the format
    //     return {
    //         fields,
    //     };
    // }
}
